import numpy as np
from itertools import combinations
import random
fix_seed =42
random.seed(fix_seed)
np.random.seed(fix_seed)
def beam(q, L_max, D, W, k):
    fix_seed =42
    random.seed(fix_seed)
    np.random.seed(fix_seed)
    n, d = D.shape
    L_max = min(L_max, d)
    zero_density = [] 
    S = []            
    S_scores = []     
    psi, t = 24, 100  
    params = (psi, t)
    
    L = [(i,) for i in range(d)]
    L_scores = sinne_scores(L, D, q, params)
    
    print('finish first layer score')
    for candidate, score in zip(L, L_scores):
        if score == -np.inf:
            zero_density.append(frozenset(candidate))
    S, S_scores, L = update_top_subspaces(S, S_scores, L, L_scores, k, W)
    print('finish first layer')

    removed_attrs = {candidate[0] for candidate, score in zip([(i,) for i in range(d)], L_scores) if score == -np.inf}
    remaining_attrs = [i for i in range(d) if i not in removed_attrs]
    if len(remaining_attrs) < 2:
        return S
    print('finish removing -inf attribute')

    L = list(combinations(remaining_attrs, 2))
    print('begin layer 2 score')
    L_scores = sinne_scores(L, D, q, params)
    
    print('finish second layer score')
    for candidate, score in zip(L, L_scores):
        if score == -np.inf:
            zero_density.append(frozenset(candidate))
    S, S_scores, L = update_top_subspaces(S, S_scores, L, L_scores, k, W)
    
    for l in range(3, L_max + 1):
        L_new = []
        for candidate in L:
            candidate_set = set(candidate)
            for attr in range(d):
                if attr not in candidate_set:
                    new_candidate = tuple(sorted(candidate + (attr,)))
                    L_new.append(new_candidate)
        L_new = list(set(L_new))
        L_filtered = []
        for candidate in L_new:
            candidate_set = set(candidate)
            skip = False
            for zd in zero_density:
                if zd.issubset(candidate_set):
                    skip = True
                    break
            if not skip:
                L_filtered.append(candidate)
        L_new = L_filtered
        if not L_new:
            break
        L_scores = sinne_scores(L_new, D, q, params)
        print('finish layer score: ',l)
        for candidate, score in zip(L_new, L_scores):
            if score == -np.inf:
                zero_density.append(frozenset(candidate))
        S, S_scores, L = update_top_subspaces(S, S_scores, L_new, L_scores, k, W)
    return S

def update_top_subspaces(S, S_scores, L, L_scores, k, W):
    S_extended = S + list(L)
    S_scores_extended = S_scores + list(L_scores)
    if len(S_scores_extended) > 0:
        sorted_indices = np.argsort(S_scores_extended)
        sorted_indices = sorted_indices[:k]
        S_new = [S_extended[i] for i in sorted_indices]
        S_scores_new = [S_scores_extended[i] for i in sorted_indices]
    else:
        S_new, S_scores_new = [], []

    if len(L) > 0:
        sorted_indices_L = np.argsort(L_scores)
        sorted_indices_L = sorted_indices_L[:min(W, len(L))]
        L_new = [L[i] for i in sorted_indices_L]
    else:
        L_new = []
    return S_new, S_scores_new, L_new

def sinne_scores(L, D, q, params):
    fix_seed =42
    random.seed(fix_seed)
    np.random.seed(fix_seed)
    psi, t = params
    n, _ = D.shape
    scores = []
    eps = np.finfo(float).eps
    for candidate in L:
        data = D[:, candidate]   
        query = q[list(candidate)]    
        fm = np.zeros((t, psi), dtype=bool)
        for j in range(t):
            if n < psi:
                sample_indices = np.random.choice(n, psi, replace=True)
            else:
                sample_indices = np.random.choice(n, psi, replace=False)
            spheres = data[sample_indices, :]  
            
            diff = spheres[:, np.newaxis, :] - spheres[np.newaxis, :, :]
            dist_matrix = np.sum(diff**2, axis=2)  
            np.fill_diagonal(dist_matrix, np.inf)
            radii = np.min(dist_matrix, axis=1)  
            
       
            diff_query = spheres - query  
            dists_query = np.sum(diff_query**2, axis=1)  

            fm[j, :] = dists_query <= radii
        
        score = np.mean(np.any(fm, axis=1))
        if score < eps:
            score = -np.inf
        scores.append(score)
    return np.array(scores)
